\section{Programmiergrundlagen}
        \subsection{Skripte}
        Ein Skript ist eine Sammlung von MATLAB Befehlen, die in einer Datei gemeinsam abgespeichert und ausgeführt werden können. Die Dateiendung eines solchen Skripts ist \texttt{.m} 
        \subsubsection*{Vorgehensweise}
        \begin{itemize}
                \item Rechtsklick im Current Folder \textrightarrow New \textrightarrow Script
                \item Eingeben der gewünschten MATLAB Befehle im Editor analog zur Verwendung im Command Window
                \item Speichern des Skriptes
                \item Ausführen durch Eingabe des Dateinamens ohne Dateiendung im Command Window oder den Run Button in der Navigationsleiste bei geöffnetem Editor.
        \end{itemize}
        \subsubsection*{Kommentare}
        Mittels des \texttt{\%} Zeichens kann ein Kommentar eingefügt werden, das beim Ausführen des Skriptes nicht beachtet wird.
        \begin{Codelösung}{Skriptbeispiel}
                \begin{lstlisting}
% Erzeuge 3x3 Matrix
A = [1 2 3; 4 5 6; 7 8 9];

% Erste Spalte der Matrix als Spaltenvektor
b = A(:,1);

% Transponiert b zu Zeilenvektor
c = b';
                \end{lstlisting}
        \end{Codelösung}
        \subsubsection*{Vorteile von Skripten gegenüber der Eingabe im Command Window}
        \begin{itemize}
                \item Skripte können beliebig oft ausgeführt werden, ohne die Befehle jedes mal erneut eingeben zu müssen.
                \item Rechenweg bleibt komplett dokumentiert und kann einfacher überprüft und angepasst werden.
                \item Komplexe Abläufe lassen sich klar gliedern und durch Kommentare strukturieren.
        \end{itemize}
        \clearpage
        \subsection{Funktionen}
        Funktionen werden ebenfalls in einem \texttt{.m}-File gespeichert, enthalten im Gegensatz zu einem einfachen Skript jedoch Ein- und Ausgabeargumente und werden mit einem \texttt{end} beendet.
        \begin{center}
                \texttt{function [Ausgabe] = Funktionsname(Eingabe)}     
        \end{center}
                Die Verwendung von eckigen Klammern ist lediglich bei Verwendung mehrerer Ausgabeargumente notwendig, kann jedoch auch bei nur einem Argument verwendet werden. \\
                Der Funktionsname sollte dem Dateinamen entsprechen, um die Funktion auch in anderen Skripten ausführen zu können.
                \begin{Codelösung}{Funktionsbeispiel}
                        \begin{lstlisting}
function A = Flaecheninhalt(r)

A = pi * r^2;
end       
                        \end{lstlisting}

                \end{Codelösung}
                \noindent
                Die Funktion kann nun durch Eingabe im Command Window oder innerhalb eines Skriptes mit beispielsweise
                \begin{center}
                        \texttt{Flaecheninhalt(3)}
                \end{center}
                aufgerufen werden und gibt somit den Flächeninhalt eines Kreises mit dem Radius 3 zurück.
        \subsection{Schleifen und Bedingungen}
                Schleifen ermöglichen das mehrfache Ausführen eines Codeblocks, was jedoch immer an eine Bedingung geknüpft ist.
                \subsubsection*{for-Schleife}
                Der Codeblock wird für eine definierte Anzahl an Durchläufen ausgeführt. Auch eine Schleife muss immer mit einem \texttt{end} beendet werden.
                \begin{Codelösung}{Beispiel for-Schleife}
                        \begin{lstlisting}
summe = 0;
for i = 1:10
        summe = summe + i;
end
                        \end{lstlisting}
                \end{Codelösung}
        \noindent Diese Schleife berechnet die Summe der Zahlen 1 bis 10.
        \subsubsection*{while-Schleife}
        Der Codeblock wird so lange ausgeführt, bis eine gegebene Bedingung nicht mehr erfüllt wird.
        \begin{Codelösung}{Beispiel while-Schleife}
                \begin{lstlisting}
n = 0;
zahl = 2;

while zahl < 1000
    zahl = zahl^2;
    n = n+1;
end
                \end{lstlisting}
        \end{Codelösung}
        \noindent In diesem Fall wird geprüft, wie oft man eine Zahl quadrieren kann, bevor sie den Wert 1000 überschreitet.
        \subsubsection*{if-Bedingungen}
        \texttt{if}-Bedingungen sind in der Programmierumgebung wichtig, um auf unterschiedliche Arten von Eingabewerten zu reagieren. Je nach Ergebnis einer logischen Prüfung, wird nur ein Teil des bestehenden Codes ausgeführt.
        \begin{Codelösung}{Beispiel if-Bedingung}
                \begin{lstlisting}
T = 80;

if T>100
        disp('Dampf');
elseif T > 0
        disp('fluessig');
else
        disp('gefroren')
end
                \end{lstlisting}
        \end{Codelösung}
        \subsubsection*{Logische Operatoren}
        \begin{tabularx}{\textwidth}{|X|X|}
                \hline
                \textbf{Operator} & \textbf{Bedeutung}\\
                \hline
                \texttt{==} & gleich \\
                \hline
                \texttt{\raisebox{0.5ex}{\texttildelow}=} & ungleich\\
                \hline
                \texttt{<} & kleiner als\\
                \hline
                \texttt{>} &größer als\\
                \hline
                \texttt{<=} & kleiner gleich\\
                \hline
                \texttt{>=} & größer gleich\\
                \hline
        \end{tabularx}
        \subsection{Beispielaufgaben}
        \subsubsection*{Aufgabe 1}
        Gegeben seien die beiden Vektoren 
        \[a=\begin{pmatrix}
                2 & 4 & 7
        \end{pmatrix}\]
        \[b=\begin{pmatrix}
                1 & 6 & 3
        \end{pmatrix}\]
        Führen Sie folgende Aufgaben innerhalb eines Skriptdes durch.\\
        1. Addieren Sie die beiden Vektoren.\\
        2. Multiplizieren Sie die beiden Vektoren elementweise.\\
        3. Lassen Sie sich beide Ergebnisse mittel \texttt{disp()} ausgeben.
        \subsubsection*{Lösung 1}
        \begin{Codelösung}{vectorAddMul.m}
                \begin{lstlisting}
a = [2 4 7];
b = [1 , 6 , 3]
c = a + b;
d = a .* b;
disp(c);
disp(d);
                \end{lstlisting}
        \end{Codelösung}
        \noindent Ausführen des Skriptes mittels Command Window Eingabe.
        \begin{center}
                \texttt{vectorAddMul}
        \end{center}
        \subsubsection*{Aufgabe 2}
        Schreiben Sie eine Funktion \texttt{nullstellen(a,b,c)} zur Berechnung von Nullstellen einer beliebigen quadratischen Funktion. Nutzen Sie hierfür die Mitternachtsformel:
        \[x = \frac{-b\pm \sqrt{b^2-4ac}}{2a}\]

        \noindent Lassen Sie sich anschließend die Nullstellen der folgenden Funktion ausgeben.
        \[ f(x) = (1+i)x^2 - (5+i)x + 10\]
        \subsubsection*{Lösung 2}
        \begin{Codelösung}{nullstellen.m}
                \begin{lstlisting}
function [x1, x2] = nullstellen(a,b,c)
    x1 = (-b+sqrt((b^2)-4*a*c))/(2*a); 
    x2 = (-b-sqrt((b^2)-4*a*c))/(2*a); 
end
                \end{lstlisting}
        \end{Codelösung}
        \noindent Aufruf der Funktion mittels der Command Window Eingabe
        \begin{center}
        \texttt{
[a,b] = nullstellen(1 +1*i, -5 - 1*i, 10)}
        \end{center}
        \subsubsection*{Aufgabe 3}
        Schreiben Sie eine MATLAB Funktion \texttt{integral(a,b,c,xStart,xEnd)} welche mittels numerischer Integration und der Rechteckregel das bestimmte Integral einer quadratischen Funktion approximieren kann. Zudem soll die Funktion nur dann das Integral berechnen, wenn der Startwert kleiner als der Endwert ist.

        \[A=\int_{xStart}^{xEnd}{f(x) dx} \approx \Delta x \cdot \sum_{i=0}^{n-1}f(x_i)\]

        Berechne anschließend
        \[\int_{0}^{7}3x^2 + 2x -7 dx\]
        \subsubsection*{Lösung 3}
        \begin{Codelösung}{integral.m}
                \begin{lstlisting}
function A = integral(a, b, c, xStart, xEnd)
    if xEnd > xStart
        n = 10000;
        dx = (xEnd - xStart) / n;
        x = x_start : dx : x_end - dx;
        f = a*x.^2 + b*x + c;
        A = sum(f) * dx;
    else
        disp('Endwert muss hoeher als Startwert sein');
    end
end
                \end{lstlisting}
        \end{Codelösung}
        